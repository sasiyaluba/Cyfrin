# 审计总结

## 概述

当前项目为一个简单的跨链桥，跨链桥的主要功能是将资产从一条链转移到另一条链，因此实现的主要思路为：

在 L1 上部署一个 Vault，L2 部署一个 Vault。

**L1 -> L2**

1. 用户 L1 的资产转移的 L1 的 Vault 中。

2. 跨链桥的链下程序监听 L1 的 Vault 的 deposit 事件。

3. 当监听到 deposit 事件后，链下程序构造 L2 上的交易，将等额资产从 L1 的 Vault 中转移到 L2 的 Vault 中。

**L2 -> L1**

1. 用户 L2 的资产转移的 L2 的 Vault 中。

2. 用户发起转账交易，bridge 供应商的签署者签署该交易，并将签名返回给用户

3. L1 的用户根据签名，从 bridge 中提取资产。

## 审计经验

1. 当存在预签名情况时，必须考虑到签名重放攻击，此处要保证有 `nonce` 和 `chainId` 的存在。

2. Web3 中各角色也不能完全信任，必须考虑内部作恶的可能性。

3. 在校验 deposit 上限时，不能用 `balance` 来判断是否达到上限，因为 `balance` 是容易被操作的，从而导致 dos 攻击。

4. 在编写 `deposit` 函数时，不能由用户传入 `from`，因为 `from` 是可以伪造的，应该直接使用 `msg.sender`。

5. 老生重谈，在进行 `deposit`, `withdraw`等操作时，不能直接信任用户传入的 amount，而是采用状态变量记录的方式，或者采用余额记录的方式。

6. 项目内部存在用户传入 `calldata` 并进行 `functionCall` 的操作时，必须考虑到该函数在执行时，是否需要权限控制？因为在 `functionCall` 的内部 `msg.sender` 是项目本身，此时很可能存在一些操作被随意调用。同时，还需要考虑重入的风险，最好为非`view`函数添加`nonReentrant`修饰符。当然，还存在只读可重入的风险（一般涉及到价格操纵），此时需要考虑是否存在价格操纵的可能性。

7. 如果存在一个集中 Factory 进行合约的创建，那么注意在创建 ERC20 合约时，其构造函数中是否存在`mint`到`msg.sender`的操作？如果存在则该操作最好禁止，因为一般 Factory 其行为仅仅为合约创建，因此代币转入合约后可能无法转出。

8. !!! 我认为，在对合约进行审计时，要保证脑海中有一个完整的执行框架，执行流程无非是：校验 -> 状态变量更新 -> 外部调用 -> 事件触发，这个逻辑顺序非常重要，缺一不可。拿到合约时，要想是否有校验？外部调用是否安全？事件是否触发？如果没有，则需要考虑是否存在漏洞。

## 合约学习

在编写消息加密和消息解密时，经常会没有思路，此处总结出一种思路：

当面对 `v,r,s` 时，意味着，我们需要使用 `address signer = ECDSA.recover(messageHash, v, r, s);` 来求出 signer, 而后与权限地址做对比，从而判断签名是否有效。

那么，对于 signer 来说，他只需要对 `messageHash` 进行签名即可，他不需要关注内容（安全方面还是需要的，只是说在当前加解密的场景下）。签名后获得 `v,r,s`，然后将其传递给合约，合约通过 `ECDSA.recover` 来获得 signer 的地址。

那么在合约内部，我们就使用 `address signer = ECDSA.recover(messageHash, v, r, s);` 来获得 signer 的地址，然后与权限地址做对比，从而判断签名是否有效。

但是，对于合约来说，只有 `messageHash` 是不够的，因为进行预签名，肯定是要进行一系列调用的，只从 `messageHash` 无法获得 `message`的信息。因此，在合约内是需要通过先构造出 `message`，然后再进行 `keccak256` 来获得 `messageHash` 的，再进行 `ECDSA.recover` 来获得 signer 的地址。

因此遇到上述问题的时候，总结思路如下

1. 先构造出 `message`，然后进行 `keccak256` 来获得 `messageHash`。
2. 然后使用 `ECDSA.recover` 来获得 signer 的地址。
